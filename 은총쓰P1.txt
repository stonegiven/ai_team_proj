import pygame
import copy
import random
from itertools import product
import time
import math

class Node:
    def __init__(self, state, parent=None):
        self.state = state
        self.parent = parent
        self.children = []
        self.visits = 0
        self.wins = 0

    def is_fully_expanded(self):
        return len(self.children) == len(self.state.get_legal_moves())

    def best_child(self, c_param=1.4):
        if not self.children:
            return self  # If no children, return itself as fallback
        weights = [
            (child.wins / child.visits) + c_param * math.sqrt(2 * math.log(self.visits) / child.visits)
            for child in self.children
        ]
        return self.children[weights.index(max(weights))]


class MCTS:
    def __init__(self, root):
        self.root = root

    def best_action(self):
        """Explore the entire game tree to determine the best action."""
        self.explore_tree(self.root)
        return self.root.best_child(c_param=0)  # Select the child with the highest win rate

    def explore_tree(self, node):
        """Recursively explore all possible game states."""
        # If the node is a terminal state, update its reward and propagate back
        if node.state.is_terminal():
            reward = node.state.result()
            self.backup(node, reward)
            return

        # If the node is not fully expanded, expand it
        if not node.is_fully_expanded():
            self.expand(node)

        # Recursively visit all children
        for child in node.children:
            self.explore_tree(child)

    def expand(self, node):
        """Expand the current node by generating all possible children."""
        legal_moves = node.state.get_legal_moves()
        tried_children = [child.state for child in node.children]

        for move in legal_moves:
            # Check if the move is already simulated
            if move not in tried_children:
                # Create a new state and child node
                new_state = node.state.apply_move(move)
                new_node = Node(new_state, parent=node)
                node.children.append(new_node)

    def backup(self, node, reward):
        """Backpropagate the reward through the tree."""
        while node is not None:
            node.visits += 1
            node.wins += reward
            node = node.parent


import time

class P1:
    def __init__(self, board, available_pieces):
        self.pieces = [(i, j, k, l) for i in range(2) for j in range(2) for k in range(2) for l in range(2)]
        self.board = board  # Current game board (0: empty, 1~16: piece indices)
        self.available_pieces = available_pieces  # Available pieces as tuples

    def select_piece(self):
        """Select the best piece to give to the opponent using MCTS."""
        start_time = time.time()  # Start timing for selecting a piece

        worst_piece = None
        min_threat = float('inf')

        for piece in self.available_pieces:
            # Check if this piece leads to immediate loss
            if self._causes_immediate_loss(piece):
                continue  # Skip this piece if it directly causes a loss

            # Otherwise, simulate and calculate the threat level
            threat = self._simulate_game(piece, simulate_for_opponent=True)

            if threat < min_threat:
                min_threat = threat
                worst_piece = piece

        end_time = time.time()  # End timing
        print(f"Time taken to select a piece: {end_time - start_time:.4f} seconds")  # Print the time taken

        return worst_piece

    def _causes_immediate_loss(self, piece):
        """Check if giving this piece leads to immediate loss."""
        for row, col in product(range(4), range(4)):
            # Skip occupied cells
            if self.board[row][col] != 0:
                continue

            # Simulate placing the piece on the board
            simulated_board = copy.deepcopy(self.board)
            simulated_board[row][col] = self.pieces.index(piece) + 1

            # Create a simulated game state
            simulated_state = GameState(simulated_board, self.available_pieces, self.pieces, is_opponent_turn=True)

            # Check if this move results in a win for the opponent
            if simulated_state._check_win():
                return True

        return False

    def place_piece(self, selected_piece):
        """Place the selected piece on the board and return the best location."""
        start_time = time.time()  # Start timing for placing a piece

        available_locs = [(row, col) for row, col in product(range(4), range(4)) if self.board[row][col] == 0]
        best_loc = None
        max_reward = float('-inf')

        for loc in available_locs:
            # Temporarily apply the move to the board
            self.board[loc[0]][loc[1]] = self.pieces.index(selected_piece) + 1

            # Simulate the move
            reward = self._simulate_game(selected_piece, simulate_for_opponent=False, location=loc)

            # Restore the board to its original state
            self.board[loc[0]][loc[1]] = 0

            # Update the best location if this move is better
            if reward > max_reward:
                max_reward = reward
                best_loc = loc

        end_time = time.time()  # End timing
        print(f"Time taken to place a piece: {end_time - start_time:.4f} seconds")  # Print the time taken

        return best_loc

    def _simulate_game(self, piece, simulate_for_opponent, location=None):
        """Simulate the game to its conclusion using Monte Carlo simulations."""
        # Track the current game state
        try:
            # Clone the current board and available pieces using deepcopy
            sim_board = deepcopy(self.board)
            sim_available_pieces = deepcopy(self.available_pieces)

            # Apply the move if a location is specified
            if location:
                sim_board[location[0]][location[1]] = self.pieces.index(piece) + 1

            # Temporarily remove the piece from available pieces
            if piece in sim_available_pieces:
                sim_available_pieces.remove(piece)

            # Create a simulation game state
            game_state = GameState(sim_board, sim_available_pieces, self.pieces, simulate_for_opponent)
            root = Node(game_state)

            # Run MCTS simulations
            mcts = MCTS(root)
            simulations = 1000  # Adjust simulation count as needed
            best_action = mcts.best_action()

            # Return the result of the best action
            return best_action.state.result()
        except Exception as e:
            print(f"Simulation error: {e}")
            return 0


class GameState:
    def __init__(self, board, available_pieces, pieces, is_opponent_turn):
        self.board = board
        self.available_pieces = available_pieces
        self.pieces = pieces
        self.is_opponent_turn = is_opponent_turn

    def get_legal_moves(self):
        """Return all legal moves (row, col) for the current player."""
        return [(row, col) for row, col in product(range(4), range(4)) if self.board[row][col] == 0]

    def is_terminal(self):
        """Check if the game is in a terminal state (win or full board)."""
        return self._check_win() or not self.get_legal_moves()

    def random_play(self):
        """Simulate a random play."""
        legal_moves = self.get_legal_moves()
        if not legal_moves:
            return self

        move = random.choice(legal_moves)
        new_board = [row[:] for row in self.board]
        piece = random.choice(self.available_pieces)
        new_board[move[0]][move[1]] = self.pieces.index(piece) + 1

        return GameState(new_board, self.available_pieces, self.pieces, not self.is_opponent_turn)

    def result(self):
        """Evaluate the result of the game. 1 if win, 0 if loss."""
        if self._check_win():
            return 1 if not self.is_opponent_turn else 0
        return 0

    def _check_win(self):
        """Check if the current board state is a winning state."""
        for row in range(4):
            if self._check_line([self.board[row][col] for col in range(4)]):
                return True
        for col in range(4):
            if self._check_line([self.board[row][col] for row in range(4)]):
                return True
        if self._check_line([self.board[i][i] for i in range(4)]) or self._check_line([self.board[i][3 - i] for i in range(4)]):
            return True
        return False

    def _check_line(self, line):
        if 0 in line:
            return False
        pieces = [self.pieces[idx - 1] for idx in line if idx > 0]
        for i in range(4):
            if len(set(p[i] for p in pieces)) == 1:
                return True
        return False
